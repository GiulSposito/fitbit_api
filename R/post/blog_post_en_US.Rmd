---
title: "Comparing Fitbit and Polar HR data"
output:
  html_document:
    df_print: paged
---

The wearable Fitbit bracelet captures the heart rate based on the expansion and contraction of the capillaries in the skin throught measurement of the reflection and absorption of LED lights, and an analysis algorithms, different from the method used heart rate monitor Polar H7, which captures the electrical signals from the heart beat. In this post, we will access a WebAPI using OAuth2.0 to get Fitbit data and compare it with those obtained by a Polar H7, imported from a GPX file during the same training session. How good is the Fitbit measures comparing to Polar H7?

<!--more-->

## Introduction

In this post we will compare acquisition of heart rate data performed by two different devices in the same session training: a sport *wearable* wristband called **[Fitbit](https://www.fitbit.com/)** and a **[Polar](https://www.polar.com/br)** heart monitoring.

How good is the **Fitbit** measures comparing to **Polar H7**? They agree with the measures? How the differences are distributed? I did a MTB session using both devices, now I can use R to access the data and compare the measures.

### the devices

The bracelet model used was **[Fitbit ChargeHR] (https://www.fitbit.com/be/chargehr)**, which is no longer marketed, but use the same technology embedded in newer models. The **Fitbit** uses a proprietary technology called *[PurePulse](https://www.fitbit.com/purepulse)* a to perform a heart rate measurement. When your heart beats, yours capillaries in the skin expand and contract based on changes in blood volume. The light of the *PurePulse LEDs* on your Fitbit device reflect on the skin to detect changes in blood volume, and finely tuned algorithms are applied to measure heart rate automatically and continuously.

![fitbit Charge HR](./images/fitbit.jpg)

The heart rate monitor used was **[Polar H7 Heart Rate Sensor](https://www.polar.com/us-en/products/accessories/h10_heart_rate_sensor)**, which works as an Electrocardiogram, or in other words, electrodes in contact with the skin detect the electrical signal triggered by the heart in each heart beat.

![Polar H7](./images/polar.png)

In this way we will compare the quality and accuracy of heart rate data obtained from two very different technologies.

## Data Acquisitions

The first steps is to get the devices data, and for each one we will use a different strategy, for **Fitbit** we'll access the data via `Web API`, and for the **Polar H7** we'll extract from the training session **GPX** file.

### Fitbit

The **Fitbit** data is availabe throught an [Web API](https://dev.fitbit.com/build/reference/web-api/) in the Fitbit's [Development Portal](https://dev.fitbit.com/). It's necessary to use [Oauth 2.0](https://oauth.net/2/) protocol for authorization and authentication, so you must obtain an [ID and Secret](https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/) doing a registration in the portal first.

Follow the steps:

1. Log in and go to [Manage > Register An App](https://dev.fitbit.com/apps/new)
1. enter whatever you want for Application name and description
1. in the application website box, any valid URL (usually I create a link from a google doc)
1. for organization put “self”
1. for organization website any valid URL
1. for OAuth 2.0 Application Type select “Personal”
1. for Callback URL put in http://localhost:1410/
1. for Default Access Type select “Read Only”
1. click “save”

After that, you should now be at a page that shows your

1. The App Name you choose
1. OAuth 2.0 Client ID
1. Client Secret
1. URL Callback you defined
1. Authentication URL
1. Refresh Token URL"

These parameters will be used to get or renew the `API [Access Token](https://www.oauth.com/oauth2-servers/access-tokens/)`. Fill a `fitbit_config.yml` configuration file (see the *appendix* at the end of this post) with them and we'll be ready to request and get the **Fitbit** data using the` httr package`.


```{r loadingSettings, eval=FALSE, message=FALSE, warning=FALSE}

# loading ID and Secret 
# (see the post apendix)
library(yaml)
.config <- yaml.load_file("./config/fitbit_config.yml")

# performing authentication and autorization
library(httr)
fb_app   <- oauth_app(.config$app_name, .config$client_id, .config$client_secret)
fb_oauth <- oauth_endpoint(authorize = .config$auth_uri, access = .config$refresh_token_uri)
token    <- oauth2.0_token(fb_oauth, fb_app, scope = c("activity","heartrate","sleep"), cache = F, use_basic_auth = T)

```

The `oauth_app`,` oauth_endpoint` and `oauth2.0_token` functions execute the authentication and authorization flow of the` OAuth 2.0` protocol to obtain the `Access Token`, which must be passed for each request made to the `Fitbit Web API`. When executing these function the browser will be called for you to authenticate in the site, and then the callback URL will be called by passing the `authentication token` confirming that you have access to the APIs.

Then, we can call the *[endpoint](https://dev.fitbit.com/build/reference/web-api/heart-rate/)* responsible for querying heart rate information.

```{r heartRateEndPointFake, eval=FALSE, warning=FALSE, message=FALSE}

# request HR data
# Resource URL - There are two acceptable formats for retrieving time series data:
#
# GET https://api.fitbit.com/1/user/[user-id]/activities/heart/date/[date]/[period].json
# GET https://api.fitbit.com/1/user/[user-id]/activities/heart/date/[base-date]/[end-date].json
#
# user-id:   The encoded ID of the user. Use "-" (dash) for current logged-in user.
# base-date: The range start date, in the format yyyy-MM-dd or today.
# end-date:	 The end date of the range.
# date:	     The end date of the period specified in the format yyyy-MM-dd or today.
# period:	   The range for which data will be returned. Options are 1d, 7d, 30d, 1w, 1m.

# shortcut to define a url to get heart rate
library(glue)
gen_hr_url <- function(.user_id="-",.date="today",.period="1d")
  glue("https://api.fitbit.com/1/user/{.user_id}/activities/heart/date/{.date}/{.period}.json")


# make a HTTP GET 
# 2019-02-24 is the date of my MTB 
resp <- GET(gen_hr_url(.date="2019-02-24"), conf=config(token=token))

# check if the result is 200 (OK)
resp$status_code

```

```{r hbFitbitCache, echo=FALSE, cache=TRUE}

resp <- readRDS("./data/fitbit_http_resp.rds")
resp$status_code

```


Se tudo o ocorreu bem, a [requisição http](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview) devolveu [status 200](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), então podemos processar o [json](https://www.w3schools.com/js/js_json_intro.asp) do conteúdo da resposta para extrair os dados de frequencia cardíaca requisitada.

```{r fbJsonHandling, cache=TRUE, message=FALSE, warning=FALSE}

# process response content
library(jsonlite)
data <- fromJSON(content(resp, "text"))

# get the heart rate data 
# see the response json format in https://dev.fitbit.com/build/reference/web-api/heart-rate/ 
hrdt <- data$`activities-heart-intraday`$dataset

# convert the "text time data" in in date-time and create a tibble
library(tidyverse)
library(lubridate)
hrdt %>% 
  as.tibble() %>% 
  mutate( datetime = paste0("2019-02-24 ", time) ) %>% # adding "day" to time info
  mutate( datetime = ymd_hms(datetime) ) %>% 
  rename(fitbit_hr = value) %>% 
  select(datetime, fitbit_hr) -> fitbit_hr

# let's see we got
library(knitr)
library(kableExtra)
fitbit_hr %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Os dados de frequência cardíaca do **fitbit** obtidos são medições minuto à minuto da taxa batimentos por minuto, é possível visualizar a frequência cardíaca ao longo do dia.

```{r fbHeartHate, cache=TRUE, message=FALSE, warning=FALSE}
# ploting HR x Datatime
fitbit_hr %>% 
  ggplot() +
  geom_line(aes(x=datetime, y=fitbit_hr, color=fitbit_hr)) +
  scale_color_gradient(name="heart rate (bpm)",low="green", high="red") +
  theme_minimal()
```

### Polar H7

Diferente do **fitbit** para obter os dados de frequência cardíaca do **Polar H7** o caminho mais fácil é puxar os dados da App ao qual ele estava sincronizado, na ocasião, usei a aplicação [Strava](https://www.strava.com/). Como fizemos no [post "Ploting your mtb track with r"]([https://yetanotheriteration.netlify.com/2018/01/ploting-your-mtb-track-with-r/]), iremos fazer o download do arquivo [GPX](https://en.wikipedia.org/wiki/GPS_Exchange_Format) contendo os dados registrados durante a sessão de exercício, direto do site da App, e processar o XML para extrar os dados que procuramos.

```{r loadGPX, cache=TRUE, message=FALSE, warning=FALSE}

# read gpx file
library(XML)
gpx_file <- htmlTreeParse("./data/Visconde_de_Sotello_e_Moenda.gpx", useInternalNodes = T)

# trackpoint XML  structure 
#
# <trkpt lat="-22.7036870" lon="-46.7560630">
#   <ele>675.1</ele>
#   <time>2019-02-24T11:13:36Z</time>
#   <extensions>
#     <gpxtpx:TrackPointExtension>
#       <gpxtpx:hr>105</gpxtpx:hr>
#     </gpxtpx:TrackPointExtension>
#   </extensions>
# </trkpt>

# extract (by xpath) times
dtime <- xpathSApply(gpx_file, path = "//trkpt/time", xmlValue) 
hr    <- xpathSApply(gpx_file, path = "//trkpt/extensions/trackpointextension/hr", xmlValue) 

# create a tibble
polar_hr <- tibble(
  datetime  = ymd_hms(dtime),
  polar_hr = as.integer(hr)
)

# overview
summary(polar_hr)

```

```{r polarHead, cache=TRUE}
# lets see the content
polar_hr %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```


Como no **fitbit**, os dados de frequência cardíaca do **Polar H7** obtidos são medições minuto à minuto da taxa batimentos por minuto, é possível visualizar a frequência cardíaca ao longo exercício.

```{r plotPolar, cache=TRUE}

# Visualize dataset
polar_hr %>% 
  ggplot() +
  geom_line(aes(x=datetime, y=polar_hr, color=polar_hr)) +
  scale_color_gradient(name="heart rate (bpm)",low="green", high="red") + 
  theme_minimal()

```


## Análise

### Comparando Medições

Com os dados em mãos, podemos comparar as medições obtidas pelos dois dispositivos. Em ambas as medições, a frequencia cardíaca é medida em batimentos por minuto e armazenada minuto à minuto, vamos então fazer um join no timestamp da medição.

```{r joinHRs, cache=TRUE}

# join both datasets by the timestamp
# the datetime in polar_hr data are in UTC and the fitbit are in local time
# ajusting the "timezone" and merging both devices removing 2 hours from polar data
polar_hr %>% 
  mutate(datetime = datetime - hours(2)) %>% 
  inner_join(fitbit_hr, by = "datetime") -> hr_data


# let's see what we got
hr_data %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Ploting both data toghether.

```{r plotHRdata, cache=TRUE} 
# lets plot the dataset
hr_data %>% 
  gather(device, hr, -datetime) %>% 
  ggplot(aes(x=datetime, y=hr, group=device)) +
  geom_line(aes(color=device)) +
  theme_minimal()
```

Podemos ver que as medições do **Fitbit** seguem as do **Polar H7** com extraordinária precisão, podemos avaliar melhor, a relação entre eles, comparando os valores de cada medição plotando a relação entre ambos.

```{r corrPlot, cache=TRUE}

# lets see the correlation
hr_data %>% 
  ggplot(aes(x=polar_hr, y=fitbit_hr)) +
  geom_point() +
  stat_smooth(method = "lm") +
  theme_minimal()

```

A correlação entre as duas medições, embora não seja exatamente precisa, é evidente, vamos testá-la

```{r corrTestes, cache=TRUE}
# correlation test
cor.test(x=hr_data$polar_hr, y=hr_data$fitbit_hr, alternative = "two.sided")

```

Podemos modelar as medições do **fitbit** em fução do **polar h7** e analisar como os resíduos se comportam.

```{r corrModel, cache=TRUE}
# check the quality of a linear correlation
model <- lm(fitbit_hr~polar_hr, hr_data)
summary(model)

par(mfrow = c(2, 2))
plot(model)
```


### Concordância (Teste de Bland-Altman)

Bland e Altman publicaram em 1983 o primeiro artigo com uma metodologia alternativa ao cálculo do coeficiente de correlação, metodologia empregada até então. O coeficiente de correlação não avalia concordância e sim associação, coisas bem diferentes.

A metodologia proposta inicialmente por Bland e  Altman para avaliar a concordância entre duas variáveis (X e Y) parte de uma visualização gráfica a partir de um gráfico de dispersão entre a diferença das duas variáveis (X - Y) e a média das duas (X + Y)/2. 

Vamos reproduzir a metodologia com esses dados.

```{r blandAltMath, cache=TRUE}

# math for Bland Altman test
hr_data %>% 
  mutate(
    mean      = (polar_hr + fitbit_hr)/2,
    diff      = fitbit_hr - polar_hr,
    diff.pct  = (fitbit_hr - polar_hr)/polar_hr,
    diff.mn   = mean(diff),
    diff.sd   = sqrt(var(diff)),
    upper.lim = diff.mn + (2*diff.sd), 
    lower.lim = diff.mn - (2*diff.sd),
  ) -> hr_data_ba

# let's see
hr_data_ba %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

Neste gráfico é possível visualizar o viés (o quanto as diferenças se afastam do valor zero), o erro (a dispersão dos pontos das diferenças ao redor da média), além de outliers e tendências.

A partir do cálculo do viés ( d ) e do seu desvio-padrão (sd) é possível chegar aos limites de concordância: d ± 1,96sd, que devem ser calculados e incluídos no gráfico. Se o viés apresenta distribuição normal, estes limites representam a região em que se encontram 95% das diferenças nos casos estudados.

```{r baltmanPlot, cache=TRUE}

# Bland Altman plot
hr_data_ba %>% 
  ggplot(aes(x=mean, y=diff)) + 
  geom_point() +
  geom_hline(yintercept=0, color="grey") +
  geom_hline(yintercept=hr_data_ba$diff.mn[1], linetype=2, color="blue") +
  geom_hline(yintercept=hr_data_ba$upper.lim[1], linetype=2, color="red") +
  geom_hline(yintercept=hr_data_ba$lower.lim[1], linetype=2, color="red") +
  theme_minimal()

```

Visualmente vemos que não há viés (média das diferenças é próxima a zero) e de que os a disperção das diferenças estão dentro de um intervalo bem pequeno:

- Viés: `r hr_data_ba$diff.mn[1]`
- Dispersão ($2\sigma$): `r hr_data_ba$upper.lim[1]` bpm

Antes de seguir com a análise, vamos dar uma olhada na distribuição das diferenças das medições do **fitbit** em relação ao **polar h7**:

```{r diffplot, cache=TRUE}
# Overview
summary(hr_data_ba$diff.pct)


# Visualizing
hr_data_ba %>% 
  ggplot() +
  geom_density(aes(x=diff.pct), color="blue", fill="blue" ) +
  theme_minimal()

```


Para o teste Bland-Altman , o que deve ser avaliado é se as diferenças entre as variáveis dependem ou não do tamanho da medida. Isto pode ser feito através de uma correlação entre as diferenças e as médias, que deve ser nula. 

```{r corrBlandAlt, cache=TRUE}
# correlation between diff and mean
cor.test(x=hr_data_ba$mean, y=hr_data_ba$diff, alternative = "two.sided")
```

Nossos números mostraram alguma correlação, onde deveria não ser encontrada. Já a hipótese do viés ser ou não igual a zero pode ser testada por um teste-t para amostras emparelhadas. 

```{r ttestBlandAlt, cache=TRUE}
# t.test between paired samples
t.test(x=hr_data_ba$mean, y=hr_data_ba$diff, paired = T)
```

Aqui, o viés mostrou-se praticamente zero, demonstrando concodância entre as medições do **Fitbit** e do **Polar H7**.

## Conclusion

Neste post, usamos o pacote `httr` para acessar uma `WebAPI` usando `OAuth2.0` para obter dados do **Fitbit** e compará-los com os obtidos por um **Polar H7**, importados de um arquivo GPX.

O **fitbit** capitura a frequência cardíaca baseado na expansão e contração dos capilares na pele e faz essa medição com base na reflexão/absorção de luzes de LED, além de algorítimos de análise. Esse método mostrou-se comparável e em concordância com as medições obtidas no **polar h7**, que captura os sinais elétricos do batimento.

## Apendix 

### config.yml

Para evitar que *senhas*, *IDs* e *secrets* fiquem *hard coded* e acabem versionados e expostos no [Github](https://github.com/) por acidente, eu costumo criar um aquivo [yaml](https://en.wikipedia.org/wiki/YAML) e coloca-lo no `.gitignore`. Neste código, o arquivo yaml tem o seguinte formato:


```{r yamlTemplate, eval=FALSE}
# registe a new app in Fitbit developer site at # https://dev.fitbit.com/apps/new
# follow the instruction on https://hydroecology.net/getting-detailed-fitbit-data-with-r/
# fill these var contents and save as 'fitbit_config.yml'

app_name: ""
client_id: ""
client_secret: ""
callback_url: ""
auth_uri: ""
refresh_token_uri: ""
```

### Referências

Referências utilizadas neste post:

1. https://www.polar.com
1. https://www.fitbit.com
1. https://dev.fitbit.com
1. https://seer.ufrgs.br/hcpa/article/view/11727/7021
1. https://yetanotheriteration.netlify.com/2018/01/ploting-your-mtb-track-with-r/
1. https://www.telegraph.co.uk/technology/news/12086337/Fitbit-heart-rate-tracking-is-dangerously-inaccurate-lawsuit-claims.html