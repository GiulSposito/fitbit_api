---
title: "Comparing Fitbit and Polar HR data"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

No MTB que fiz no último fim de semana eu usei tanto um Polar H7 quando e um Fitbit Charge 

<!--more-->

## Introduction

Neste post vamos comparar aquisição de dados de frequência cardíaca realizado por dois dispositivos diferentes: uma pulseira *wearable* de esporte chamada **fitbit** e numa cinta de monitoramento cardíaco Polar.

### Devices

O modelo de pulseira utilizado foi o **[fitbit ChargeHR](https://www.fitbit.com/be/chargehr)**, que atualmente já não é mais comercializado. Para realizar a medição da frequência cardíaca **fitbit** uma tecnologia própria chama [PurePulse](https://www.fitbit.com/purepulse) When your heart beats, your capillaries expand and contract based on blood volume changes. PurePulse LEDs (light-emitting diodes) on your Fitbit device reflect onto the skin to detect blood volume changes, and finely-tuned algorithms are applied to measure heart rate automatically and continuously. The heart-rate icon you see on the display tells you if you're in 1 of 3 heart-rate zones.

![fitbit Charge HR](https://images-na.ssl-images-amazon.com/images/I/51wafNtYODL.jpg)

O monitor de frequencia cardíaca usado, foi o **[Polar H7 Heart Rate Sensor](https://www.polar.com/us-en/products/accessories/h10_heart_rate_sensor)**, que trabalha como um Eletro Cardiograma, ou seja, eletrodos em contato com a pele detectam o sinal elétrico disparado pelo coração a cada batida cardíaca.

![Polar H7](https://cdn.shopify.com/s/files/1/0904/0726/products/polar-polar-accessories-black-retail-package-med-xl-30-45-inches-polar-h7-bluetooth-smart-chest-transmitter-7795311878_x700.png?v=1538423599)

Dessa maneira podemos comparar a qualidade e a precisão dos dados de frequência cardíaca obtidos com tecnologias bem diferentes.

## Data Acquisitions

Primeiro passo é obter os dados dos dispositivos.

### Fitbit

Para o **fitbit**, o acesso dos dados pode ser feita via [Web API](https://dev.fitbit.com/build/reference/web-api/) que utiliza [Oauth 2.0](https://oauth.net/2/) para autenticação d autorização, então é necessário obter [ID e Secret](https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/) fazendo o cadastro no portal de desenvolvimento.

1. enter whatever you want for Application name and description
1. in the application website box, paste the URL of your google sheet from Step 1
1. for organization put “self”
1. for organization website put the URL of your google sheet from Step 1
1. for OAuth 2.0 Application Type select “Personal”
1. for Callback URL put in http://localhost:1410/
1. for Default Access Type select “Read Only”
1. click “save”

You should now be at a page that shows your

1. OAuth 2.0 Client ID
1. Client Secret

Com os parametros de acesso em mãos preencha um arquivo de configuração `fitbit_config.yml` (veja apendice) e estaremos prontos para obter os dados capturados do **fitbit** usando o `httr package`.

```{r loadingSettings, cache=TRUE, message=FALSE, warning=FALSE}

# loading ID and Secret 
# (see the post apendix)
library(yaml)
.config <- yaml.load_file("./config/fitbit_config.yml")

# performing authentication and autorization
library(httr)
fb_app   <- oauth_app(.config$app_name, .config$client_id, .config$client_secret)
fb_oauth <- oauth_endpoint(authorize = .config$auth_uri, access = .config$refresh_token_uri)
token    <- oauth2.0_token(fb_oauth, fb_app, scope = c("activity","heartrate","sleep"), cache = F, use_basic_auth = T)

```

As funções `oauth_app`, `oauth_endpoint` e `oauth2.0_token` executam o fluxo de autenticação e autorização do protocolo `OAuth 2.0` para obter o `Token`de acesso, que precisará ser passado para cada requisição feita à API do site do **fibtib**.

Podemos então fazer a chamada ao *[endpoint](https://dev.fitbit.com/build/reference/web-api/heart-rate/)* responsável pela consulta às informações de frequência cardíaca.

```{r heartRateEndPoint, cache=TRUE, warning=FALSE, message=FALSE}

# request HR data
# Resource URL - There are two acceptable formats for retrieving time series data:
#
# GET https://api.fitbit.com/1/user/[user-id]/activities/heart/date/[date]/[period].json
# GET https://api.fitbit.com/1/user/[user-id]/activities/heart/date/[base-date]/[end-date].json
#
# user-id:   The encoded ID of the user. Use "-" (dash) for current logged-in user.
# base-date: The range start date, in the format yyyy-MM-dd or today.
# end-date:	 The end date of the range.
# date:	     The end date of the period specified in the format yyyy-MM-dd or today.
# period:	   The range for which data will be returned. Options are 1d, 7d, 30d, 1w, 1m.

# shortcut to define a url to get heart rate
library(glue)
gen_hr_url <- function(.user_id="-",.date="today",.period="1d")
  glue("https://api.fitbit.com/1/user/{.user_id}/activities/heart/date/{.date}/{.period}.json")


# make a HTTP GET 
# 2019-02-24 is the date of my MTB 
resp <- GET(gen_hr_url(.date="2019-02-24"), conf=config(token=token))

# check if the result is 200 (OK)
resp$status_code

```

Se tudo o ocorreu bem, a [requisição http](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview) devolveu [status 200](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), então podemos processar o [json](https://www.w3schools.com/js/js_json_intro.asp) do conteúdo da resposta para extrair os dados de frequencia cardíaca requisitada.

```{r fbJsonHandling, cache=TRUE, message=FALSE, warning=FALSE}

# process response content
library(jsonlite)
data <- fromJSON(content(resp, "text"))

# get the heart rate data 
# see the response json format in https://dev.fitbit.com/build/reference/web-api/heart-rate/ 
hrdt <- data$`activities-heart-intraday`$dataset

# convert the "text time data" in in date-time and create a tibble
library(tidyverse)
library(lubridate)
hrdt %>% 
  as.tibble() %>% 
  mutate( datetime = paste0("2019-02-24 ", time) ) %>% # adding "day" to time info
  mutate( datetime = ymd_hms(datetime) ) %>% 
  rename(fitbit_hr = value) %>% 
  select(datetime, fitbit_hr) -> fitbit_hr

# let's see we got
library(knitr)
library(kableExtra)
fitbit_hr %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Os dados de frequência cardíaca do **fitbit** obtidos são medições minuto à minuto da taxa batimentos por minuto, é possível visualizar a frequência cardíaca ao longo do dia.

```{r fbHeartHate, cache=TRUE, message=FALSE, warning=FALSE}
# ploting HR x Datatime
fitbit_hr %>% 
  ggplot() +
  geom_line(aes(x=datetime, y=fitbit_hr, color=fitbit_hr)) +
  scale_color_gradient(name="heart rate (bpm)",low="green", high="red") +
  theme_minimal()
```

### Polar H7

Diferente do **fitbit** para obter os dados de frequência cardíaca do **Polar H7** o caminho mais fácil é puxar os dados da App ao qual ele estava sincronizado, na ocasião, usei a aplicação [Strava](https://www.strava.com/). Como fizemos no [post "Ploting your mtb track with r"]([https://yetanotheriteration.netlify.com/2018/01/ploting-your-mtb-track-with-r/]), iremos fazer o download do arquivo [GPX](https://en.wikipedia.org/wiki/GPS_Exchange_Format) contendo os dados registrados durante a sessão de exercício, direto do site da App, e processar o XML para extrar os dados que procuramos.

```{r loadGPX, cache=TRUE, message=FALSE, warning=FALSE}

# read gpx file
library(XML)
gpx_file <- htmlTreeParse("./data/Visconde_de_Sotello_e_Moenda.gpx", useInternalNodes = T)

# trackpoint XML  structure 
#
# <trkpt lat="-22.7036870" lon="-46.7560630">
#   <ele>675.1</ele>
#   <time>2019-02-24T11:13:36Z</time>
#   <extensions>
#     <gpxtpx:TrackPointExtension>
#       <gpxtpx:hr>105</gpxtpx:hr>
#     </gpxtpx:TrackPointExtension>
#   </extensions>
# </trkpt>

# extract (by xpath) times
dtime <- xpathSApply(gpx_file, path = "//trkpt/time", xmlValue) 
hr    <- xpathSApply(gpx_file, path = "//trkpt/extensions/trackpointextension/hr", xmlValue) 

# create a tibble
polar_hr <- tibble(
  datetime  = ymd_hms(dtime),
  polar_hr = as.integer(hr)
)

# overview
summary(polar_hr)

```

```{r polarHead, cache=TRUE}
# lets see the content
polar_hr %>% 
  head(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```


Como no **fitbit**, os dados de frequência cardíaca do **Polar H7** obtidos são medições minuto à minuto da taxa batimentos por minuto, é possível visualizar a frequência cardíaca ao longo exercício.

```{r plotPolar, cache=TRUE}

# Visualize dataset
polar_hr %>% 
  ggplot() +
  geom_line(aes(x=datetime, y=polar_hr, color=polar_hr)) +
  scale_color_gradient(name="heart rate (bpm)",low="green", high="red") + 
  theme_minimal()

```




## Apendix 

### config.yml

Para evitar que senhas, app_ID e o secret fiquem *hard coded* e acabem versionados e expostos no [Github](https://github.com/) por acidente, eu costumo criar um aquivo [yaml](https://en.wikipedia.org/wiki/YAML) e coloca-lo no `.gitignore`. Neste código o arquivo yaml tem o seguinte formato:


```{r yamlTemplate, eval=FALSE}
# registe a new app in Fitbit developer site at # https://dev.fitbit.com/apps/new
# follow the instruction on https://hydroecology.net/getting-detailed-fitbit-data-with-r/
# fill these var contents and save as 'fitbit_config.yml'

app_name: ""
client_id: ""
client_secret: ""
callback_url: ""
auth_uri: ""
refresh_token_uri: ""
```

### Referências

Referências utilizadas neste post:

1. [https://www.polar.com]
1. [https://www.fitbit.com]
1. [https://dev.fitbit.com]
1. [https://seer.ufrgs.br/hcpa/article/view/11727/7021]
1. [https://yetanotheriteration.netlify.com/2018/01/ploting-your-mtb-track-with-r/]
1. [https://www.telegraph.co.uk/technology/news/12086337/Fitbit-heart-rate-tracking-is-dangerously-inaccurate-lawsuit-claims.html]
